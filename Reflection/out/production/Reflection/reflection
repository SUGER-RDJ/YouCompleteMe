反射：

1.反射机制允许任何程序在执行期借助 Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到
2.加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个calss对象）这个对象包含了类的完整结构信息。通过这个对象得到类的结构，故形象的称之为反射

Java反射机制可以完成：
1.在运行时判断任意一个对象所属的类
2.在运行时构造任意一个类的对象
3.在运行时得到任意一个类所具有的成员变量和方法
4.在运行时调用任意一个对象的成员变量和方法
5.生成动态代理

反射机制优缺点：
1.优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑
2.缺点：使用反射基本是解释执行，对执行速度有影响

Class类：
1.Class也是类，因此继承了Object类
2.Class类对象不是new出来的，而是系统创建的
3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次
4.每个类的实例都会记得自己由哪个Class实例所生成
5.通过Class可以完整的得到一个类的完整结构，通过一系列API
6.Class对象是存放在堆中的
7.类的字节码二进制数据是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等）

获取Class类对象方式：
1.已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName获取，可能抛出异常，用于配置文件，读取类全路径，加载类
2.已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高，多用于参数传递，比如通过反射得到相应构造器对象
3.已知某个类的实例，调用该实例的getClass方法获取Class对象，常用于通过创建好的对象，获取Class对象
4.其他方式     ClassLoader classLoader = 对象.getClass().getClassLoader();
              Class<?> cls4 = classLoader.loadClass(类的全类名);

哪些类型有Class对象：
1.外部类，成员内部类，静态内部类，局部内部类，匿名内部类
2.interface：接口
3.数组
4.enum：枚举
5.annotation：注解
6.基本数据类型
7.void

类加载：
1.静态加载：编译时加载相关的类，如果没有则报错，依赖性过强
2.动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性
类加载时机：1.当创建对象时  2.当子类被加载时  3.调用类中的静态成员时  4.通过反射
class文件需要加载到虚拟机后才能运行和使用，系统加载class文件主要分三步：加载，连接，初始化，连接部分又分三步：验证，准备，解析

通过反射创建对象：
方式一：调用类中的public修饰的无参构造器
方式二：调用类中的指定构造器
Class相关方法：
newInstance：调用类中的无参构造器，获取对应类的对象
getConstructor：根据参数列表，获取对应的构造器信息
getDeclareConstructor：根据参数列表，获取对应的构造器信息
Constructor类相关方法：
setAccessible：爆破
newInstance：调用构造器

通过反射访问类中的成员：
1.根据属性名获取Field对象
2.爆破：field.setAccessible(true);
3.访问
4.如果是静态属性，则set和get中的参数o，可以写成null


